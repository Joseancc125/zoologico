<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Zoológico — Topología Distribuida</title>
    <style>
      body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial; margin:18px; background:#f6fbfc}
      .wrap{max-width:1200px;margin:0 auto}
      header{display:flex;justify-content:space-between;align-items:center}
      h1{margin:0;font-size:20px}
      .topology{display:flex;gap:18px;margin-top:18px}
      .col{flex:1}
      .cameras{display:grid;grid-template-columns:repeat(1,1fr);gap:12px}
      .camera{background:#fff;padding:8px;border-radius:8px;border:1px solid #e6f2f4}
      .camera .frame{width:100%;height:120px;background:#ddd;display:block;border-radius:6px;position:relative;overflow:hidden}
      .cluster{display:flex;flex-direction:column;gap:8px;align-items:center}
      .nodes{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
      .node{width:120px;height:90px;background:#fff;border-radius:8px;border:1px solid #dfeff0;display:flex;align-items:center;justify-content:center;position:relative}
      .node img{max-width:100%;max-height:100%}
      .cloud{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
      .cloud .cloud-node{width:40px;height:30px;border-radius:6px;background:#fff;border:1px solid #e1eef0}
      .arrow{font-size:24px;color:#0ea5a4;text-align:center}
      .graph{background:#fff;padding:12px;border-radius:8px;border:1px solid #e6f2f4}
      .legend{font-size:13px;color:#666;margin-top:8px}
      .btn{background:#0ea5a4;color:#fff;padding:8px 10px;border-radius:6px;border:none;cursor:pointer}
      .row{display:flex;gap:8px;align-items:center}
      .bbox{position:absolute;border:3px solid rgba(255,0,0,0.9);box-sizing:border-box}
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <h1>Zoológico — Topología distribuida</h1>
        <div class="row">
          <a href="/" class="btn">Volver al dashboard</a>
        </div>
      </header>

      <p>Ejemplo conceptual: cámaras → cluster local (detección urgente) → nube (análisis histórico).</p>

      <div class="topology">
        <div style="flex:1">
          <div class="graph">
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
              <label style="font-weight:600">Cámara:</label>
              <select id="camera_select"><option value="">Todas</option></select>
              <label style="font-weight:600">Rango:</label>
              <select id="hours_select"><option value="24">24h</option><option value="48">48h</option><option value="168">7d</option><option value="0">Custom</option></select>
              <input id="custom_from" type="datetime-local" style="display:none"/>
              <input id="custom_to" type="datetime-local" style="display:none"/>
              <button id="btn_refresh" class="btn">Refrescar</button>
              <button id="btn_play" class="btn">Play</button>
              <button id="btn_pause" class="btn" style="display:none">Pause</button>
            </div>
            <div style="display:flex;gap:12px">
              <div style="flex:1;position:relative">
                <canvas id="video_canvas" width="640" height="360" style="background:#000;display:block;border-radius:6px"></canvas>
                <div id="bbox_layer" style="position:absolute;left:0;top:0;width:640px;height:360px;pointer-events:none"></div>
              </div>
              <div style="width:220px">
                <div style="display:flex;gap:8px;margin-bottom:8px">
                  <button id="btn_export" class="btn">Descargar imagen</button>
                  <button id="btn_embed" class="btn">Generar iFrame</button>
                </div>
                <div style="font-size:13px;color:#333"><strong>Frame:</strong> <span id="frame_info">-</span></div>
                <div style="margin-top:8px;font-size:13px;color:#666">Filtrado / paginación</div>
                <div style="margin-top:8px"><button id="btn_prev" class="btn">Prev</button> <button id="btn_next" class="btn">Next</button></div>
              </div>
            </div>
            <div class="legend">Stream simulado desde miniaturas en `uploads` — dibuja bounding boxes reales.</div>
          </div>
        </div>

        <div style="width:340px" class="graph">
          <h3 style="margin-top:0">Tendencia de detecciones (últimas 24h)</h3>
          <canvas id="chart" width="300" height="160"></canvas>
          <div class="legend">Tendencia</div>
        </div>
      </div>
    </div>

    <script>
      // utilities
      const API = '/visual/frames';
      let frames = [];
      let playIndex = 0;
      let playing = false;
      let playTimer = null;

      const cameraSelect = document.getElementById('camera_select');
      const hoursSelect = document.getElementById('hours_select');
      const btnRefresh = document.getElementById('btn_refresh');
      const btnPlay = document.getElementById('btn_play');
      const btnPause = document.getElementById('btn_pause');
      const videoCanvas = document.getElementById('video_canvas');
      const bboxLayer = document.getElementById('bbox_layer');
      const ctx = videoCanvas.getContext('2d');
      const frameInfo = document.getElementById('frame_info');
      const btnExport = document.getElementById('btn_export');
      const btnEmbed = document.getElementById('btn_embed');
      const btnPrev = document.getElementById('btn_prev');
      const btnNext = document.getElementById('btn_next');

      function parseQuery() {
        const qp = new URLSearchParams(location.search);
        return {camera_id: qp.get('camera_id') || '', hours: qp.get('hours') || '24'};
      }

      async function fetchFrames(camera_id, hours){
        const q = new URLSearchParams();
        if(camera_id) q.set('camera_id', camera_id);
        q.set('hours', hours||24);
        q.set('limit', 300);
        const res = await fetch(API + '?' + q.toString());
        if(!res.ok) return [];
        const data = await res.json();
        return data.results || [];
      }

      function populateCameraList(items){
        const cams = Array.from(new Set(items.map(i=>i.camera_id).filter(Boolean)));
        cameraSelect.innerHTML = '<option value="">Todas</option>' + cams.map(c=>`<option value="${c}">${c}</option>`).join('');
      }

      function clearBBoxes(){ bboxLayer.innerHTML = ''; }

      function drawBBoxesOnTop(detections, imgW, imgH, canvasW, canvasH){
        clearBBoxes();
        if(!detections || !detections.length) return;
        const scaleX = canvasW / imgW;
        const scaleY = canvasH / imgH;
        detections.forEach(d=>{
          const [x1,y1,x2,y2] = d.bbox;
          const left = x1 * scaleX; const top = y1 * scaleY; const w = (x2-x1) * scaleX; const h = (y2-y1) * scaleY;
          const el = document.createElement('div');
          el.className = 'bbox';
          el.style.left = left + 'px'; el.style.top = top + 'px'; el.style.width = w + 'px'; el.style.height = h + 'px';
          el.style.borderColor = 'rgba(255,0,0,0.9)';
          el.title = (d.label || '') + ' ' + Math.round((d.confidence||0)*100) + '%';
          bboxLayer.appendChild(el);
        });
      }

      async function renderFrame(item){
        // item should contain thumbnail_url and optionally detections
        if(!item) return;
        const src = item.thumbnail_url || item.frame_url || item.frame || item.image;
        if(!src) return;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = src;
        await new Promise((res, rej)=>{ img.onload = ()=>res(); img.onerror = ()=>res(); setTimeout(()=>res(), 2000); });
        // resize canvas to image aspect
        const cw = videoCanvas.width; const ch = videoCanvas.height;
        // draw image letterboxed
        ctx.clearRect(0,0,cw,ch);
        const arImg = img.naturalWidth / (img.naturalHeight || 1);
        const arCanvas = cw / ch;
        let dw = cw, dh = ch, dx = 0, dy = 0;
        if(arImg > arCanvas){ // image wider
          dw = cw; dh = Math.round(cw / arImg); dy = Math.round((ch - dh)/2);
        } else {
          dh = ch; dw = Math.round(ch * arImg); dx = Math.round((cw - dw)/2);
        }
        ctx.drawImage(img, dx, dy, dw, dh);
        // draw boxes scaled relative to natural image size
        const detections = (item.detections || item.predictions || (item.metadata && item.metadata.detections) || []);
        // if metadata was JSON string, try parse
        let dets = detections;
        if(typeof dets === 'string'){
          try{ dets = JSON.parse(dets); }catch(e){ dets = []; }
        }
        // some items store detections inside metadata key
        if(!dets.length && item.metadata){
          try{ const m = (typeof item.metadata === 'string')? JSON.parse(item.metadata): item.metadata; dets = m.detections || dets; }catch(e){}
        }
        // if boxes are in absolute pixels for natural size, scale using img.naturalWidth/Height and canvas draw dims
        const imgW = img.naturalWidth || dw; const imgH = img.naturalHeight || dh;
        drawBBoxesOnTop(dets, imgW, imgH, dw, dh);
        frameInfo.textContent = `${item.camera_id || '-'} @ ${new Date((item.received_at||0)*1000).toLocaleString()} (${item.id||''})`;
      }

      function startPlay(){
        if(playing) return; playing = true; btnPlay.style.display='none'; btnPause.style.display='inline-block';
        playTimer = setInterval(()=>{ if(frames.length===0) return; renderFrame(frames[playIndex]); playIndex = (playIndex+1) % frames.length; }, 1000);
      }
      function stopPlay(){ playing=false; btnPlay.style.display='inline-block'; btnPause.style.display='none'; clearInterval(playTimer); playTimer=null; }

      btnPlay.addEventListener('click', ()=>startPlay());
      btnPause.addEventListener('click', ()=>stopPlay());
      btnRefresh.addEventListener('click', ()=>loadAndRender());
      btnPrev.addEventListener('click', ()=>{ if(frames.length===0) return; playIndex = Math.max(0, playIndex-1); renderFrame(frames[playIndex]); });
      btnNext.addEventListener('click', ()=>{ if(frames.length===0) return; playIndex = Math.min(frames.length-1, playIndex+1); renderFrame(frames[playIndex]); });

      btnExport.addEventListener('click', ()=>{
        const url = videoCanvas.toDataURL('image/png');
        const a = document.createElement('a'); a.href = url; a.download = `zoologico_frame_${Date.now()}.png`; document.body.appendChild(a); a.click(); a.remove();
      });

      btnEmbed.addEventListener('click', ()=>{
        const cam = cameraSelect.value; const hours = hoursSelect.value;
        const src = location.origin + location.pathname + `?camera_id=${encodeURIComponent(cam)}&hours=${encodeURIComponent(hours)}`;
        const snippet = `<iframe src="${src}" width="640" height="360" frameborder="0"></iframe>`;
        prompt('Copia el código del iframe', snippet);
      });

      // when hours=0 show custom inputs
      hoursSelect.addEventListener('change', ()=>{
        const v = hoursSelect.value;
        document.getElementById('custom_from').style.display = (v==='0')? 'inline-block':'none';
        document.getElementById('custom_to').style.display = (v==='0')? 'inline-block':'none';
      });

      async function loadAndRender(){
        stopPlay();
        const cam = cameraSelect.value || '';
        const hours = hoursSelect.value || 24;
        frames = await fetchFrames(cam, hours);
        populateCameraList(frames);
        playIndex = 0;
        if(frames.length>0) await renderFrame(frames[0]);
      }

      // init: parse query string to preselect
      (async ()=>{
        const q = parseQuery();
        if(q.camera_id) cameraSelect.value = q.camera_id;
        if(q.hours) hoursSelect.value = q.hours;
        await loadAndRender();
      })();

      // small trend chart (counts per hour from frames)
      const cctx = document.getElementById('chart').getContext('2d');
      function drawTrend(){
        const w = cctx.canvas.width, h = cctx.canvas.height; cctx.clearRect(0,0,w,h);
        const now = Date.now()/1000; const hours = 24; const buckets = new Array(hours).fill(0);
        frames.forEach(f=>{ const r = f.received_at || 0; const diffh = Math.floor((now - r)/3600); if(diffh>=0 && diffh<hours) buckets[Math.max(0,hours-1-diffh)] += 1; });
        const maxv = Math.max(1, ...buckets);
        const barw = w / hours;
        for(let i=0;i<hours;i++){ const val=buckets[i]; const bh = (val/maxv)*(h-20); cctx.fillStyle='#06b6d4'; cctx.fillRect(i*barw+1, h-bh-6, barw-2, bh); }
      }
      // update trend periodically
      setInterval(()=>{ drawTrend(); }, 2000);

    </script>
  </body>
</html>
